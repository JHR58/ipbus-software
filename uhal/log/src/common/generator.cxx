
#include <sstream>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <boost/algorithm/string.hpp>

static const std::string gLogLevelsChar[] = { "Emergency" , "Alert" , "Critical" , "Error" , "Warning" , "Notice" , "Info" , "Debug" };

static const std::vector< std::string > gLogLevels ( gLogLevelsChar , gLogLevelsChar+8 );



std::string gDivider (	"// " + std::string ( 150,'=' ) + "\n" +
						"// WARNING! This file is automatically generated! Do not modify it! Any changes will be overwritten!\n" +
						"// " + std::string ( 150,'=' ) + "\n" );



void fileHeaders ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
	aHppFile	<< "\n"
				<< "#ifndef _log_hpp_\n"
				<< "#define _log_hpp_\n"
				<< "\n"
				<< "#include <uhal/log/log_backend.hpp>\n"
				<< "#include <uhal/log/log_inserters.hpp>\n"
				<< "\n"
				<< "namespace uhal{\n"
				<< "\n"
				<< gDivider
				<< "\n";
	aHxxFile	<< "\n"
				<< "namespace uhal{\n"
				<< "\n"
				<< gDivider
				<< "\n";
	aCppFile	<< "\n"
				<< "#include <uhal/log/log.hpp>\n"
				<< "\n"
				<< "namespace uhal{\n"
				<< "\n"
				<< gDivider
				<< "\n";
}


void log_configuration_functions ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
	std::stringstream lIfDefs, lIfDefs2, lEndIfs;

	for ( std::vector< std::string >::const_iterator lIt = gLogLevels.begin() ; lIt != gLogLevels.end() ; ++lIt )
	{
		lIfDefs << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( *lIt ) << "\n";
		lIfDefs2 << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( *lIt ) << " // A waste of time to change any level below this if it is going to disabled by compile-time checking anyway... \n"
				 << "\t\tlog_configuration::mLoggingIncludes" << *lIt << " = true;\n";
		lEndIfs << "\t#endif\n";
		aHppFile << "struct " << *lIt << " {};\n";
		aHppFile << "void setLogLevelTo ( const " << *lIt << "& );\n";
		aCppFile << "void setLogLevelTo ( const " << *lIt << "& )\n"
				 << "{\n"
				 << lIfDefs2.str();

		for ( std::vector< std::string >::const_iterator lIt2 = lIt+1 ; lIt2 != gLogLevels.end() ; ++lIt2 )
		{
			aCppFile << "\t\tlog_configuration::mLoggingIncludes" << *lIt2 << " = false;\n";
		}

		aCppFile << lEndIfs.str()
				 << "}\n"
				 << "\n";
		aHppFile << "const bool& LoggingIncludes ( const " << *lIt << "& );\n"
				 << "\n";
		aCppFile << "const bool& LoggingIncludes ( const " << *lIt << "& )\n"
				 << "{\n"
				 << lIfDefs.str()
				 << "\t\treturn log_configuration::mLoggingIncludes" << *lIt << ";\n"
				 << lEndIfs.str()
				 << "\treturn log_configuration::mFalse;\n"
				 << "}\n"
				 << "\n";
	}

	aHppFile << "class log_configuration\n"
			 << "{\n"
			 << "\tlog_configuration();\n"
			 << "\tvirtual ~log_configuration();\n"
			 << "\n";

	for ( std::vector< std::string >::const_iterator lIt = gLogLevels.begin() ; lIt != gLogLevels.end() ; ++lIt )
	{
		aHppFile << "\tstatic bool mLoggingIncludes" << *lIt << ";\n";
		aCppFile << "bool log_configuration::mLoggingIncludes" << *lIt << " = true; // No #ifdefs required here since they are implemented in all the access functions.\n";
		aHppFile << "\tfriend void setLogLevelTo ( const " << *lIt << "& );\n"
				 << "\tfriend const bool& LoggingIncludes ( const " << *lIt << "& );\n"
				 << "\n";
	}

	aHppFile << "\tstatic const bool mTrue;\n"
			 << "\tstatic const bool mFalse;\n"
			 << "};\n"
			 << "\n";
	aCppFile << "\n"
			 << "const bool log_configuration::mTrue = true;\n"
			 << "const bool log_configuration::mFalse = false;\n"
			 << "\n";
	aHppFile	<< gDivider
				<< "\n";
	aCppFile	<< gDivider
				<< "\n";
}


void log_functions ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
	std::stringstream lIfDefs , lEndIfs;

	for ( std::vector< std::string >::const_iterator lIt = gLogLevels.begin() ; lIt != gLogLevels.end() ; ++lIt )
	{
		lIfDefs << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( *lIt ) << "\n";
		lEndIfs << "\t#endif\n";
		std::stringstream lTemplates;
		std::stringstream lArgs;
		std::stringstream lInstructions;

		for ( uint32_t i = 0 ; i!=MAX_NUM_ARGS ; ++i )
		{
			lTemplates << " typename T" << i << " ,";
			std::string lTemplatesStr ( lTemplates.str() );
			lTemplatesStr.resize ( lTemplatesStr.size()-1 );
			lArgs << " const T" << i << "& aArg" << i << " ,";
			std::string lArgsStr ( lArgs.str() );
			lArgsStr.resize ( lArgsStr.size()-1 );
			lInstructions << "\t\t\tlog_inserter( aArg" << i << " );\n";
			aHppFile	<< "template<" << lTemplatesStr << ">\n"
						<< "void log( const " <<*lIt << "& " << boost::to_upper_copy ( *lIt ) << " ," << lArgsStr << ");\n"
						<< "\n";
			aHxxFile	<< "template<" << lTemplatesStr << ">\n"
						<< "void log( const " <<*lIt << "& " << boost::to_upper_copy ( *lIt ) << " ," << lArgsStr << " )\n"
						<< "{\n"
						<< lIfDefs.str()
						<< "\t\tif( LoggingIncludes( " << boost::to_upper_copy ( *lIt ) << " ) ){\n"
						<< "\t\t\tlog_formatter< " << *lIt << " >::head();\n"
						<< lInstructions.str()
						<< "\t\t\tlog_formatter< " << *lIt << " >::tail();\n"
						<< "\t\t}\n"
						<< lEndIfs.str()
						<< "}\n"
						<< "\n";
		}

		aHppFile	<< gDivider
					<< "\n";
		aHxxFile	<< gDivider
					<< "\n";
	}
}


void fileFooters ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
	aHppFile	<< "}\n"
				<< "#include <uhal/log/log.hxx>\n"
				<< "#endif\n";
	aHxxFile	<< "}\n"
				<< "\n";
	aCppFile	<< "}\n"
				<< "\n";
}



int main ( int argc , char* argv[] )
{
	try
	{
		std::ofstream lHppFile ( "include/uhal/log/log.hpp" );

		if ( !lHppFile.is_open() )
		{
			std::cout << "Unable to open HPP file" << std::endl;
			return 1;
		}

		std::ofstream lHxxFile ( "include/uhal/log/log.hxx" );

		if ( !lHxxFile.is_open() )
		{
			std::cout << "Unable to open HXX file" << std::endl;
			return 1;
		}

		std::ofstream lCppFile ( "src/common/log.cpp" );

		if ( !lCppFile.is_open() )
		{
			std::cout << "Unable to open CPP file" << std::endl;
			return 1;
		}

		fileHeaders ( lHppFile , lHxxFile , lCppFile );
		log_configuration_functions ( lHppFile , lHxxFile , lCppFile );
		log_functions ( lHppFile , lHxxFile , lCppFile );
		fileFooters ( lHppFile , lHxxFile , lCppFile );
		lHppFile.close();
		lHxxFile.close();
		lCppFile.close();
	}
	catch ( const std::exception& aExc )
	{
		std::cerr << "ERROR: Caught Exception : " << aExc.what() << std::endl;
		exit ( 1 );
	}
}


